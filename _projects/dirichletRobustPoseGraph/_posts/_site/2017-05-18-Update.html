<h2 id="realizing-reversing-recovering">Realizing, Reversing, Recovering</h2>

<h3 id="good-description">Good description</h3>

<blockquote>
  <p>RRR divides
loop closures into clusters based on topological similarity and then tries to find the largest subset of clusters than are consistent among themselves as well as with the underlying odometry. Consistency is considered in the chi-squared ($\mathcal{X}^2)$ sense. The algorithm first carries out consistency checks for each cluster in order to weed out incorrect links within it, followed by an intra-cluster consistency check. RRR is different from the previous algorithms as it explicitly requires convergence of the graph in order to verify the validity of loop closures. In contrast with SC and DCS, in RRR and MM loop closure decisions are not modeled as continuous variables but as discrete yes/no decisions that need to be made</p>
</blockquote>

<p><em>REF</em> $\rightarrow$ <a href="http://n.ethz.ch/~cesarc/files/IROS2014_latif.pdf">this paper</a></p>

<h3 id="getting-rrr-to-run-on-ubuntu-1604">Getting RRR to run on Ubuntu 16.04</h3>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>
<span class="gp">$ </span><span class="nb">cd</span> ~/git
<span class="gp">$ </span>git clone https://github.com/ylatif/rrr.git
<span class="gp">$ </span><span class="nb">cd </span>rrr
<span class="gp">$ </span>mkdir build; <span class="nb">cd </span>build;
<span class="gp">$ </span><span class="nb">export </span><span class="nv">G2O_INCLUDE_DIR</span><span class="o">=</span><span class="s1">'~/Documents/git/g2o/g2o/core'</span>
<span class="gp">$ </span><span class="nb">export </span><span class="nv">G2O_LIBRARIES</span><span class="o">=</span><span class="s1">'~/Documents/git/g2o/lib'</span>
<span class="gp">$ </span>EDITOR CMakeLists.txt

copy the following line into CMakeLists.txt so that gcc knows to 
compile the library with c++11. 


<span class="nb">set</span><span class="o">(</span>CMAKE_CXX_FLAGS <span class="s2">"</span><span class="k">${</span><span class="nv">CMAKE_CXX_FLAGS</span><span class="k">}</span><span class="s2"> -std=c++11"</span><span class="o">)</span>

<span class="gp">$ </span>cmake ../; make

</code></pre>
</div>

<h3 id="inital-test">Inital Test</h3>

<p>To perform an initial test of RRR, the Manhattan 3500 dataset with 10 false constraints was used. The image below shows the optimized pose graph using RRR. These results are not great ( $\mathcal{X}^2$ = 1539.7 ); however, it does show improvement over $L^2$, which has a total graph error of $\mathcal{X}^2$ = 3494.7</p>

<p align="center">
<a href="https://lh3.googleusercontent.com/WaKcKY6rO-Q3l1BwGfgCr_GYKeL10dyVTAlSQqVKLHO34DQlUF5b9zTdNiYt3JIhQZfpwbE3DhG-w90s5oqv3VguE8RctG8SbvvxFOjPpW10lhsa35C1aArE_i0Yu_4oIljFOf2InA=w630-h457-no" target="_blank"><img src="https://lh3.googleusercontent.com/WaKcKY6rO-Q3l1BwGfgCr_GYKeL10dyVTAlSQqVKLHO34DQlUF5b9zTdNiYt3JIhQZfpwbE3DhG-w90s5oqv3VguE8RctG8SbvvxFOjPpW10lhsa35C1aArE_i0Yu_4oIljFOf2InA=w630-h457-no" border="0" alt="rrrInitialTest photo Screenshot from 2017-05-18 16-40-41_zpsqb6a3lyw.png" /></a>
</p>

<p><br /><br /></p>

<h2 id="switch-factors-vs-dcs">Switch Factors Vs. DCS</h2>

<p>This section provides a performance evaluation of Switchable constraints and DCS when faced with a faulty initial graph. To do this, four commonly used datasets were selected and false loop closure constraints were added. Using these faulty datasets we quantify performance by looking at total graph error ( $\mathcal{X}^2$ ) and the number of iterations required to reach the minimum.</p>

<h3 id="manhattan-3500">Manhattan 3500</h3>

<p>The first dataset that we will look at is the commonly used Manhattan 3500. This is a simulated dataset, which was originally developed by Olson for <a href="http://rvsn.csail.mit.edu/graphoptim/eolson-graphoptim2006.pdf">this paper</a>. A picture of the initial pose graph is shown below.</p>

<p><img src="http://www.lucacarlone.com/images/M3500_eg2o.jpg" alt="man3500" align="middle" /></p>
<p align="center">
Pose Graph for Manhattan
</p>

<p><br /></p>

<p>Using the initial error free pose graph shown above, multiple false constraints were added to evaluate the performance of the robust optimization scheme. As a reference, the results for traditional $L^2$ optimization is shown below. ( Note, to reduce the amount of time to conduct this study, I limited the maximum number of iterations to 1000 )
<br /></p>

<table class="mbtablestyle">
  <thead>
    <tr>
      <th style="text-align: center">Num. False Constraints</th>
      <th style="text-align: center">Num. Iterations</th>
      <th style="text-align: center">$\mathcal{X}^2$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: center">110</td>
      <td style="text-align: center">3494.8</td>
    </tr>
    <tr>
      <td style="text-align: center">20</td>
      <td style="text-align: center">1000</td>
      <td style="text-align: center">6519.5</td>
    </tr>
    <tr>
      <td style="text-align: center">30</td>
      <td style="text-align: center">1000</td>
      <td style="text-align: center">9776.3</td>
    </tr>
    <tr>
      <td style="text-align: center">40</td>
      <td style="text-align: center">1000</td>
      <td style="text-align: center">12736.5</td>
    </tr>
    <tr>
      <td style="text-align: center">50</td>
      <td style="text-align: center">1000</td>
      <td style="text-align: center">13998.3</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>The image below shows the optimization results for DCS and switch factors. Obviously, this is quite a dramatic improvement when compared to $L^2$ optimization.</p>

<p><a href="https://lh3.googleusercontent.com/M1EST8CL49qXIGZ7SPr-ZZjPDVWBfXu6EyyAaSKR6wgf1duCYdngLFxRjmTFaPYUDUWTHzCGE8dF03u7f8bq5uHO-iXtfMgAUh93EuKAPp73jbkV3DnCCQDDuTreAi7s9zqfK5WTnQ=w630-h331-no" target="_blank"><img src="https://lh3.googleusercontent.com/M1EST8CL49qXIGZ7SPr-ZZjPDVWBfXu6EyyAaSKR6wgf1duCYdngLFxRjmTFaPYUDUWTHzCGE8dF03u7f8bq5uHO-iXtfMgAUh93EuKAPp73jbkV3DnCCQDDuTreAi7s9zqfK5WTnQ=w630-h331-no" border="0" alt="m3500Comp photo m3500Comp_zpsspuzzjkx.png" /></a></p>
<p align="center">
Optimization results for Manhattan 3500
</p>

<p><br /><br /></p>

<h3 id="intel">Intel</h3>

<p>The next dataset we will look at was collected at Intel Reseach Lab in Seattle. This pose graph was obtained by processing the raw measurements from wheel odometry and laser range finder. The raw data can be found <a href="http://ais.informatik.uni-freiburg.de/slamevaluation">here</a></p>

<p align="center">
<img src="http://www.lucacarlone.com/images/intel_lago_map.jpg" alt="sphere3500" align="middle" />
</p>
<p align="center">
Inital Pose Graph for Sphere 3500
</p>

<p><br /></p>

<p>Again, using the initial error free pose graph shown above, multiple false constraints were added to evaluate the performance of the robust optimization scheme. The results for DCS and switch factors are shown below. To provide scale, the total graph error for $L^2$ optimization when there are 10 false constraints is $\mathcal{X}^2$ = 8076.2.</p>

<p><a href="https://lh3.googleusercontent.com/97Rvrq64ZO3-uDnnsDiytm_V1xRDS0D3W_giJoh1ZypOqIiicP5n2WI08WhOEKl5AoaKSfR4tcgZDDmtDgspkWrc1tcC2c4rxOcUMG-QawCKOW1EcqZCKFzw6JIjZf9XSYy6Ku0O8Q=w630-h331-no" target="_blank"><img src="https://lh3.googleusercontent.com/97Rvrq64ZO3-uDnnsDiytm_V1xRDS0D3W_giJoh1ZypOqIiicP5n2WI08WhOEKl5AoaKSfR4tcgZDDmtDgspkWrc1tcC2c4rxOcUMG-QawCKOW1EcqZCKFzw6JIjZf9XSYy6Ku0O8Q=w630-h331-no" border="0" alt="intelComp photo intelComp_zpsod0k5ac6.png" /></a></p>
<p align="center">
Optimization results for Intel 
</p>

<p><br /><br /></p>
